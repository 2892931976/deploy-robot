// Generated by CoffeeScript 1.7.1
(function() {
  var Github, GithubApi,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  GithubApi = require('github');

  Github = (function() {
    function Github(config) {
      this.config = config;
      this.github = new GithubApi({
        version: '3.0.0',
        timeout: 3000
      });
      this.github.authenticate({
        username: this.config.username,
        password: this.config.password,
        type: 'basic'
      });
    }

    Github.prototype.scheduler = function(cb) {
      var repo, _i, _len, _ref, _results;
      _ref = this.config.repos;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        repo = _ref[_i];
        _results.push((function(_this) {
          return function(repo) {
            return _this.github.issues.repoIssues({
              user: repo.user,
              repo: repo.name,
              labels: repo.labels,
              state: 'open',
              assignee: 'none'
            }, function(err, issues) {
              if (err != null) {
                throw err;
              }
              if (issues.length > 0) {
                return cb(issues, repo);
              }
            });
          };
        })(this)(repo));
      }
      return _results;
    };

    Github.prototype.makeId = function(repo, issue) {
      return "/" + repo.user + "/" + repo.name + "/issues/" + issue.number;
    };

    Github.prototype.selfAssign = function(repo, issue) {
      return this.github.issues.edit({
        user: repo.user,
        repo: repo.name,
        number: issue.number,
        assignee: this.config.username
      });
    };

    Github.prototype.finish = function(repo, issue, content, close) {
      return this.comment(repo, issue, content, (function(_this) {
        return function() {
          if (close) {
            return _this.github.issues.edit({
              user: repo.user,
              repo: repo.name,
              number: issue.number,
              assignee: null,
              state: 'closed'
            });
          }
        };
      })(this));
    };

    Github.prototype.comment = function(repo, issue, content, cb) {
      return this.github.issues.createComment({
        user: repo.user,
        repo: repo.name,
        number: issue.number,
        body: content
      }, function(err, comment) {
        if (err != null) {
          throw err;
        }
        return cb(comment);
      });
    };

    Github.prototype.confirm = function(repo, issue, users, currentComment, confirmMatched, stopMatched, noneMatched) {
      return this.github.issues.getComments({
        user: repo.user,
        repo: repo.name,
        number: issue.number,
        per_page: 100
      }, function(err, comments) {
        var comment, _i, _len, _ref;
        if (err != null) {
          throw err;
        }
        for (_i = 0, _len = comments.length; _i < _len; _i++) {
          comment = comments[_i];
          if ((_ref = comment.user.login, __indexOf.call(users, _ref) >= 0) && comment.id > currentComment.id) {
            if (comment.body.match(/^\s*confirm/i)) {
              return confirmMatched(repo, issue);
            } else if (comment.body.match(/^\s*stop/i)) {
              return stopMatched(repo, issue, comment.user.login);
            }
          }
        }
        return noneMatched(repo, issue);
      });
    };

    return Github;

  })();

  module.exports = Github;

}).call(this);
