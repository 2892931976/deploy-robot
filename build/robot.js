// Generated by CoffeeScript 1.7.1
(function() {
  var ChildProcess, Github, argv, config, delay, delayedTable, fs, github, list, logger, processIssues, winston,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  ChildProcess = require('child_process');

  Github = require('github');

  winston = require('winston');

  argv = require('optimist')["default"]('c', 'config.json').argv;

  logger = new winston.Logger({
    transports: [
      new winston.transports.Console({
        handleExceptions: true,
        level: 'info',
        prettyPrint: true,
        colorize: true,
        timestamp: true
      })
    ],
    exitOnError: false,
    levels: {
      info: 0,
      warn: 1,
      error: 3
    },
    colors: {
      info: 'green',
      warn: 'yellow',
      error: 'red'
    }
  });

  if (!fs.existsSync(argv.c)) {
    process.exit(1);
  }

  config = JSON.parse(fs.readFileSync(argv.c));

  github = new Github({
    version: '3.0.0'
  });

  list = [];

  delayedTable = {};

  delay = function(time, fn, id) {
    if (delayedTable[id] != null) {
      return;
    }
    list.push([Date.now() + time, fn, id]);
    return delayedTable[id] = true;
  };

  setInterval(function() {
    var cb, fn, id, now, time;
    cb = list.shift();
    now = Date.now();
    if (cb != null) {
      time = cb[0], fn = cb[1], id = cb[2];
      if (now >= time) {
        delete delayedTable[id];
        return fn();
      } else {
        return list.push(cb);
      }
    }
  }, 5000);

  github.authenticate({
    username: config.username,
    password: config.password,
    type: 'basic'
  });

  processIssues = function(issues, repo) {
    return issues.forEach(function(issue) {
      var deploy, users;
      logger.info("found deploy issue /" + repo.user + "/" + repo.name + "/issues/" + issue.number);
      logger.info("assigning to self(" + config.username + ")");
      github.issues.edit({
        user: repo.user,
        repo: repo.name,
        number: issue.number,
        assignee: config.username
      });
      deploy = function(id, delayed) {
        var self;
        if (delayed == null) {
          delayed = false;
        }
        logger.log("deploying " + id);
        self = this;
        return ChildProcess.exec(repo.command, function(err, result, error) {
          var body, close;
          body = '';
          close = true;
          if (err) {
            logger.error(err);
            if (delayed) {
              body += "再次尝试，上线失败\n\n";
            } else {
              close = false;
              body += "上线过程遇到了错误, 请尝试修复它, 我将在五分钟后再次尝试上线一次\n\n";
              delay(300000, (function() {
                return deploy(id, true);
              }), id);
            }
            if (result.length > 0) {
              body += "## 控制台输出\n```\n" + result + "\n```\n\n";
            }
            if (error.length > 0) {
              body += "## 错误输出\n```\n" + error + "\n```\n\n";
            }
          } else {
            body += "上线成功\n\n";
            if (result.length > 0) {
              body += "## 控制台输出\n```\n" + result + "\n```\n\n";
            }
          }
          return github.issues.createComment({
            user: repo.user,
            repo: repo.name,
            number: issue.number,
            body: body
          }, function(err) {
            if (close) {
              return github.issues.edit({
                user: repo.user,
                repo: repo.name,
                number: issue.number,
                state: 'closed'
              });
            }
          });
        });
      };
      logger.info("posting a comment");
      if (repo.confirm != null) {
        users = repo.confirm.split(',');
        return github.issues.createComment({
          user: repo.user,
          repo: repo.name,
          number: issue.number,
          body: '正在等待 ' + ((users.map(function(user) {
            return '@' + user;
          })).join(', ')) + ' 的确认'
        }, function(err, currentComment) {
          var delayDeploy;
          delayDeploy = function() {
            var self;
            self = this;
            logger.info("fetching comments from issue /" + repo.user + "/" + repo.name + "/issues/" + issue.number);
            return github.issues.getComments({
              user: repo.user,
              repo: repo.name,
              number: issue.number,
              per_page: 100
            }, function(err, comments) {
              var comment, _i, _len, _ref;
              if (err != null) {
                throw err;
              }
              for (_i = 0, _len = comments.length; _i < _len; _i++) {
                comment = comments[_i];
                if ((_ref = comment.user.login, __indexOf.call(users, _ref) >= 0) && comment.id > currentComment.id) {
                  logger.info("got comment /" + repo.user + "/" + repo.name + "/issues/" + issue.number + "#" + comment.id);
                  if (comment.body.match(/^\s*confirm/i)) {
                    return deploy("/" + repo.user + "/" + repo.name + "/issues/" + issue.number + "#deploy");
                  } else if (comment.body.match(/^\s*stop/i)) {
                    logger.info("closing issue /" + repo.user + "/" + repo.name + "/issues/" + issue.number);
                    return github.issues.createComment({
                      user: repo.user,
                      repo: repo.name,
                      number: issue.number,
                      body: "由于 @" + comment.user.login + " 终止了上线流程, 本次上线被关闭"
                    }, function(err) {
                      return github.issues.edit({
                        user: repo.user,
                        repo: repo.name,
                        number: issue.number,
                        assignee: null,
                        state: 'closed'
                      });
                    });
                  }
                }
                delay(15000, delayDeploy, "/" + repo.user + "/" + repo.name + "/issues/" + issue.number);
              }
            });
          };
          return delay(15000, delayDeploy, "/" + repo.user + "/" + repo.name + "/issues/" + issue.number);
        });
      } else {
        return github.issues.createComment({
          user: repo.user,
          repo: repo.name,
          number: issue.number,
          body: '正在上线...'
        }, function(err, currentComment) {
          if (err != null) {
            throw err;
          }
          return deploy("/" + repo.user + "/" + repo.name + "/issues/" + issue.number + "#deploy");
        });
      }
    });
  };

  setInterval(function() {
    var repo, _i, _len, _ref, _results;
    _ref = config.repos;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      repo = _ref[_i];
      _results.push((function(repo) {
        logger.info("fetching repo " + repo.name);
        return github.issues.repoIssues({
          user: repo.user,
          repo: repo.name,
          labels: repo.labels,
          state: 'open',
          assignee: 'none'
        }, function(err, issues) {
          if (err != null) {
            throw err;
          }
          return processIssues(issues, repo);
        });
      })(repo));
    }
    return _results;
  }, 15000);

}).call(this);
